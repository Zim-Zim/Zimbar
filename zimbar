<Enter file contents here?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE muclient>
<!-- Saved on Wednesday, February 04, 2015, 11:51 PM -->
<!-- MuClient version 4.94 -->

<!-- Plugin "Zimbar" generated by Plugin Wizard -->

<muclient>
<plugin
   name="Zimbar"
   id="f62ce1ede713ba2facae8f30"
   language="Lua"
   date_written="2015-02-04 23:50:29"
   requires="4.94"
   version="1.0"
   >

</plugin>


<!--  Get our standard constants -->

<include name="constants.lua"/>

<!--  Triggers  -->

<triggers>
  <trigger
   enabled="y"
   keep_evaluating="y"
   match="^.+the limit of your vision is.*(?:from)? here\.$"
   regexp="y"
   repeat="y"
   send_to="12"
   sequence="100"
   other_text_colour="darkred"
  >
  <send>parse_written_map("%0")</send>
  </trigger>
</triggers>

<!--  Script  -->


<script>
<![CDATA[
function complie_re() -- compile regex
	re_vision = rex.new("([Tt]he limit of your vision is .+? from here(?: and)?[,.]?)")
	re_doors = rex.new("((?:[Aa] )?[Dd]oors?.*?of (?:(?:one|two|three|four|five)? ?(?:north|northeast|east|southeast|south|southwest|west|northwest)|and|,|here| )+)")
	re_exits = rex.new("((?:[Aa]n? (?:hard to see through )?)?[Ee]xits?.*?of (?:(?:one|two|three|four|five)? ?(?:north|northeast|east|southeast|south|southwest|west|northwest)|(?:and|,|here| ))+)")
	re_population = rex.new("([^ ].+?(?: is | are )(?:(?:one|two|three|four|five)? ?(?:north|northeast|east|southeast|south|southwest|west|northwest)|and|,| )+)")
	re_directions = rex.new("(northeast|northwest|southeast|southwest|north|east|south|west)")
	re_door_and_exit_directions = rex.new("(northeast|northwest|southeast|southwest|north|east|south|west)(?=.* of )")
	re_door_and_exit_paths = rex.new("(northeast|northwest|southeast|southwest|north|east|south|west)(?!.* of )")
	return true
end

function index_matches(text, re) -- create numeric table containing matches
	matches = {}
	re:gmatch(text, function (m, t) 
		for k, v in pairs(t) do
			table.insert(matches, v)
		end
	end)
	return matches
end

function eliminate_matches(text, tbl) -- eliminate matched table values from string
	for _, v in ipairs(tbl) do
		text = text:gsub(v, "")
	end
	return text
end

function word_to_int(text) -- replace written words with integers 
	local numbers = {"one", "two", "three", "four", "five"}
	for i, word in ipairs(numbers) do
		text = text:gsub(" "..word.." ", " "..i.." "):gsub("^"..word.." ", " "..i.." "):gsub(" "..word.."$", " "..i.." ")	end
	return text
end

function expand_numbers(text) -- repeat sub-strings following integers 
text = text:gsub("(%d) (%w+)", 
	function(s1, s2) 
		return string.rep(s2.." ", tonumber(s1))
	end)
	return text
end


function get_object_paths(tbl, re, re2) -- return ordered tables for paths and corresponding objects in preparation for map construction
local path = {}
local obj = {}
	for _, v in ipairs(tbl) do
		table.insert(path, index_matches(expand_numbers(word_to_int(v)), re) or {})
		if re2 then
			table.insert(obj, (index_matches(v, re2) or {}))
		end
	end
local t = {}
	if re2 then
		t.obj = obj or {}
	end
	t.path = path or {}
	return t
end

function generate_map(tbl) -- construct the map
	map_grid = {}
	local directions = { 
		north = {x = 0, y = 1, chr = "|"},
		northeast = {x = 1, y = 1, chr = "/"},
		east = {x = 1, y = 0, chr = "-"},
		southeast = {x = 1, y = -1, chr = string.char(92)},
		south = {x = 0, y = -1, chr = "|"},
		southwest = {x = -1, y = -1, chr = "/"},
		west = {x = -1, y = 0, chr = "-"},
		northwest = {x = -1, y = 1, chr = string.char(92)}}
		
	local function origin()
		return 11, 11
	end
	
	for y = 0, 21, 1 do -- creates blank map grid
	map_grid[y] = {}
		for x = 0, 21, 1 do
			map_grid[y][x] = {value = " ", colour = "white", bg_colour = "black"} or {}
		end
	end
	
	for _, p in ipairs(map_constructors.vision.path) do -- add visible rooms
		local x, y = origin()
		for _2, dir in ipairs(p) do
			x = x + (directions[dir].x)
			y = y + (directions[dir].y)*(-1)
			map_grid[y][x].value = directions[dir].chr
			map_grid[y][x].colour = "white"
			x = x + (directions[dir].x)
			y = y + (directions[dir].y)*(-1)
			map_grid[y][x] = {value = "*", colour = "royalblue"}
		end
	end	
	for i, p in ipairs(map_constructors.exits.path) do -- add exits
		local x, y = origin()
		for _, dir in ipairs(p) do
			x = x +(directions[dir].x)*(2) 
			y = y +(directions[dir].y)*(-2)
		end
		for _, ex in ipairs(map_constructors.exits.obj[i]) do
				if (map_grid[y + (directions[ex].y)*(-1)][x + (directions[ex].x)].value == "x") or (((map_grid[y + (directions[ex].y)*(-1)][x + (directions[ex].x)].value == "/") and (directions[ex].chr == string.char(92))) or ((map_grid[y + (directions[ex].y)*(-1)][x + (directions[ex].x)].value == string.char(92)) and (directions[ex].chr == "/"))) then -- intersecting exits
					map_grid[y + (directions[ex].y)*(-1)][x + (directions[ex].x)].value = "x"
				else
					map_grid[y + (directions[ex].y)*(-1)][x + (directions[ex].x)].value = directions[ex].chr					
				end
			map_grid[y + (directions[ex].y)*(-1)][x + (directions[ex].x)].colour = "white"
			end
		end
	for i, p in ipairs(map_constructors.doors.path) do -- add doors
		local x, y = origin()
		for _, dir in ipairs(p) do
			x = x +(directions[dir].x)*(2) 
			y = y +(directions[dir].y)*(-2)
		end
		for _, dr in ipairs(map_constructors.doors.obj[i]) do
			map_grid[y + (directions[dr].y)*(-1)][x + (directions[dr].x)].value = "+"
			map_grid[y + (directions[dr].y)*(-1)][x + (directions[dr].x)].colour = "red"
		end
	end
	for i, p in ipairs(map_constructors.population.path) do -- add mobs
		local x, y = origin()
		for _, dir in ipairs(p) do
			x = x +(directions[dir].x)*(2) 
			y = y +(directions[dir].y)*(-2)
		end
		map_grid[y][x].value = "$"
		map_grid[y][x].colour = "green"
	end
	x, y = origin()
	map_grid[y][x]= {value = "@", colour = "yellow"}
	return map_grid
end

function parse_written_map(text)
	if not(got_re) then got_re = complie_re() end
	
	vision = index_matches(text, re_vision)
	doors = index_matches(text, re_doors)
	exits = index_matches(text, re_exits)

	text = eliminate_matches(text, vision)
	text = eliminate_matches(text, doors)
	text = eliminate_matches(text, exits)

	population = index_matches(text, re_population)

	map_constructors = {
		vision = (get_object_paths(vision, re_directions)),
		doors = (get_object_paths(doors, re_door_and_exit_paths, re_door_and_exit_directions)),
		exits = (get_object_paths(exits, re_door_and_exit_paths, re_door_and_exit_directions)),
		population = (get_object_paths(population, re_directions, rex.new("(^.*$)")))
	}

	output_map(generate_map(map_constructors))
end
	
function output_map(tbl)
	WindowCreate (win, 0, 0, sidebar_width, sidebar_height, miniwin.pos_center_left, 0, ColourNameToRGB("black"))  -- create window
	--WindowCircleOp (win, 3, map_outter_padding, map_outter_padding, map_box_width, map_topper_height,  -- map-topper
     --   ColourNameToRGB("blue"), 0, border, ColourNameToRGB("black"), 0, 25, 25)
	WindowCircleOp (win, 3, map_outter_padding, map_outter_padding + map_topper_height, map_box_width, map_box_height - map_outter_padding,  -- map
        ColourNameToRGB("darkorchid"), 0, border, ColourNameToRGB("black"), 0, 25, 25)
		for y, _ in ipairs(tbl) do -- output map
		for x, v in ipairs(_) do
			WindowText (win, "f", (v.value or " "),
            (x*(map_width/21)), y*(map_height/21) + map_topper_height, 0, 0,  -- rectangle
            ColourNameToRGB (v.colour or "white"), 
            false) -- not Unicode
		end
	end
	WindowShow (win,  true)  -- show it
end

function OnPluginInstall ()
	win = "Map_" .. GetPluginID ()
	WindowFont (win, "f", "FixedSys", 8, false, false, false, false)
	sidebar_width = 180
	sidebar_height = 320
	map_outter_padding = 5
	map_box_width = sidebar_width
	map_box_height = sidebar_height
	map_topper_height = 0
	map_width = map_box_width - (map_outter_padding) - 10
	map_height = ((map_box_height - map_topper_height ) - (map_outter_padding*2)) - 20
	border = 2
	TextRectangle (sidebar_width+1, 0, 0, 0, 0, 0x000000, 0, ColourNameToRGB ("black"), 0)
end -- function

]]>
</script>


</muclient>
